from python import Python, PythonObject
from CustomNN import Custom_NN_Pytorch
from Data_Loader import MNIST_Data_Loader_Pytorch, MNIST_Data_Loader_Mojo

from testing import assert_equal, assert_true, assert_false
from tensor import Tensor, TensorSpec, TensorShape
from sys.info import simdwidthof, simdbitwidth
from algorithm import parallelize, vectorize
from utils.index import Index, IndexList
from random import randn, random_si64, seed
from pathlib import path
from python import Python, PythonObject
from math import exp
from NN_Utils import NN_Utils
from Data_Loader import MNIST_Data_Loader_Pytorch
from CustomNN import Custom_NN_Pytorch, Custom_NN_Mojo

alias type = DType.float64
alias simdwidth = simdwidthof[type]()
alias mu: Float64 = 0.01
alias beta1: Float64 = 0.9
alias beta2: Float64 = 0.99
alias epsilon: Float64 = 0.00000001
alias mini_batch_size: Int = 50
alias epochs: Int = 1
alias error_target: Float32 = .1
alias input_layer_size: Int = 16
alias hidden_layer_size: Int = 52
alias output_layer_size: Int = 26
alias data_width: Int = 17
alias data_size: Int = 20000
alias training_size: Int = 16000
alias validation_size: Int = 4000
     
        
        
#def testNetwork(model: Custom_NN_Pytorch, testloader: MNIST_Data_Loader_Pytorch, device: PythonObject) -> Float64:
#    var torch = Python.import_module("torch")
#
#    var correct: Int = 0
#    var total: Int = 0     
#
#    for i in range(testloader.__len__()):
#        var images: PythonObject = testloader.batchImages[i].to(device)
#        var target: PythonObject = testloader.batchLabels[i].to(device)
#        var output: PythonObject = model.forward(images)          
#        var torch_max = torch.max(output.data, 1)
#        var predicted = torch_max[1]
#        for j in range(len(predicted)):
#            if predicted[j] == target[j]:
#                correct = correct + 1
#            total = total + 1
#
#    var accuracy: Float64 = 100.0 * correct / total
#    return accuracy


def main():
    var nn = Python.import_module("torch.nn")
    var optim = Python.import_module("torch.optim")
    var torch = Python.import_module("torch")
    var torchvision = Python.import_module("torchvision")
    var transforms = Python.import_module("torchvision.transforms")   
    var time = Python.import_module("time")
    var plt = Python.import_module("matplotlib.pyplot")
    
    var num_epochs: Int = 5
    var batchSize: Int = 64
    var inputShape: PythonObject = torch.Size([batchSize, 1, 28, 28])
    var learning_rate = 0.01
    
    var device: PythonObject = torch.device("cpu")
      
    # Load MNIST dataset
    var trainloader = MNIST_Data_Loader_Mojo(batchSize=batchSize, device=device, train=True, shuffle=True)
    var testloader = MNIST_Data_Loader_Mojo(batchSize=batchSize, device=device, train=False, shuffle=True)
           
    var train_losses: PythonObject = Python.list()
    var train_acc: PythonObject = Python.list()
    var epochs: PythonObject = Python.list()
    
    var startTime = time.perf_counter()
    for epoch in range(num_epochs):
        #print("Epoch: " + String(epoch))
        var running_loss: PythonObject = 0.0
        var cnt: Float64 = 0.0
        for i in range(trainloader.__len__()):
            #print(String(i) + " of " + String(trainloader.__len__()))
            var images = trainloader.batchImages[i].to(device)
            var labels = trainloader.batchLabels[i].to(device)

           
            #optimizer.zero_grad()
            #var outputs: PythonObject = model.forward(images)
            #var loss: PythonObject = criterion(outputs, labels)
            #loss.backward()
            #optimizer.step()
    
            #running_loss = running_loss + loss.item()
            
        # Test
        #var accuracy: Float64 = testNetwork(model=model, testloader=testloader, device=device)
        #print("Epoch " + String(epoch + 1) + " Loss: " + String(running_loss / trainloader.__len__()) + ", Validation Accuracy: " + String(accuracy) + "%")
        
        #train_losses.append(running_loss / trainloader.__len__())
        #train_acc.append(accuracy)
        #epochs.append(epoch+1)
        
    var endTime = time.perf_counter()
     
    print("Training completed in " + String(endTime - startTime) + " seconds")
      
    # Plot training loss and accuracy
    #plt.figure(figsize=(10, 5))
    #plt.subplot(1, 2, 1)
    #plt.plot(epochs, train_losses, label='Training Loss')
    #plt.title('Training Loss')
    #plt.xlabel('Epoch')
    #plt.ylabel('Loss')
    #plt.legend()

    #plt.subplot(1, 2, 2)
    #plt.plot(epochs, train_acc, label='Validation Accuracy')
    #plt.title('Validation Accuracy')
    #plt.xlabel('Epoch')
    #plt.ylabel('Accuracy (%)')
    #plt.legend()

    #plt.show()