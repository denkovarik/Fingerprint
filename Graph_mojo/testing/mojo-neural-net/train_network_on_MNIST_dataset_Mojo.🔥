from python import Python, PythonObject
from CustomNN import Custom_NN_Pytorch
from Data_Loader import MNIST_Data_Loader_Pytorch, MNIST_Data_Loader_Mojo

from testing import assert_equal, assert_true, assert_false
from tensor import Tensor, TensorSpec, TensorShape
from sys.info import simdwidthof, simdbitwidth
from algorithm import parallelize, vectorize
from utils.index import Index, IndexList
from random import randn, random_si64, seed
from pathlib import path
from python import Python, PythonObject
from math import exp
from NN_Utils import NN_Utils
from Data_Loader import MNIST_Data_Loader_Pytorch
from CustomNN import Custom_NN_Pytorch, Custom_NN_Mojo
from NN_Utils import NN_Utils
from test_utils import create_equivalent_mojo_tensor
from max.driver import cpu, Accelerator, Tensor, accelerator_count

alias type = DType.float64
     
        
        
#def testNetwork(model: Custom_NN_Mojo, testloader: MNIST_Data_Loader_Mojo) -> Float64:
#    var torch = Python.import_module("torch")
#
#    var correct: Float64 = 0.0
#    var total: Float64 = 0.0   
#
#    for i in range(testloader.__len__()):
#        var images = testloader.batchImages[i]
#        var target = testloader.batchLabels[i]
#        var output = model.forward(images)    
#        
#        var predicted: Tensor[DType.int64] = Tensor[DType.int64](TensorShape(output.shape()[0]))      
#        for i in range(output.shape()[0]):
#            var maxInd: Int = 0
#            for j in range(output.shape()[1]):
#                if output[Index(i,j)] > output[Index(i,maxInd)]:
#                    maxInd = j
#            predicted[Index(i)] = maxInd
#            
#        for j in range(predicted.shape()[0]):
#            if predicted[Index(j)] == target[Index(j)]:
#                correct = correct + 1.0
#            total = total + 1.0
#
#    var accuracy: Float64 = 100.0 * correct / total
#    return accuracy


def main():
    var nn = Python.import_module("torch.nn")
    var optim = Python.import_module("torch.optim")
    var torch = Python.import_module("torch")
    var torchvision = Python.import_module("torchvision")
    var transforms = Python.import_module("torchvision.transforms")   
    var time = Python.import_module("time")
    var plt = Python.import_module("matplotlib.pyplot")
    
    var nn_utils = NN_Utils()
    
    var num_epochs: Int = 5
    var batchSize: Int = 64
    var learning_rate = 0.01
    
    var device: PythonObject = torch.device("cpu")
      
    # Load MNIST dataset
    var trainloader = MNIST_Data_Loader_Mojo(batchSize=batchSize, device=device, train=True, shuffle=True)
    var testloader = MNIST_Data_Loader_Mojo(batchSize=batchSize, device=device, train=False, shuffle=True)
           
    var train_losses: PythonObject = Python.list()
    var train_acc: PythonObject = Python.list()
    var epochs: PythonObject = Python.list()
    
    var model: Custom_NN_Mojo = Custom_NN_Mojo() 
    
    print("\nTraining Network")
    var startTime = time.perf_counter()
    for epoch in range(num_epochs):
        var running_loss: Float64 = 0.0
        var cnt: Float64 = 0.0
        for i in range(trainloader.__len__()):
            var images = trainloader.batchImages[i]
            var labels = trainloader.batchLabels[i]
            
            # Foward
            #model.forward(images)
            #var log_softmax_mojo = model.forward(images)
   
            # Loss
            #var loss_mojo: Float64 = model.loss(labels)
    
            # Backward
            #model.backward()
            
            # Step
            #model.step()
    
            running_loss = running_loss #+ loss_mojo

        # Test
        #var accuracy: Float64 = testNetwork(model=model, testloader=testloader)
        var accuracy: Float64 = 0
        print("Epoch " + String(epoch + 1) + " Loss: " + String(running_loss / trainloader.__len__()))
        #print("Epoch " + String(epoch + 1) + " Loss: " + String(running_loss / trainloader.__len__()) + ", Validation Accuracy: " + String(accuracy) + "%")
        
        train_losses.append(running_loss / trainloader.__len__())
        train_acc.append(accuracy)
        epochs.append(epoch+1)
        
    var endTime = time.perf_counter()
     
    print("Training completed in " + String(endTime - startTime) + " seconds")
      
    # Plot training loss and accuracy
    #plt.figure(figsize=(10, 5))
    #plt.subplot(1, 2, 1)
    #plt.plot(epochs, train_losses, label='Training Loss')
    #plt.title('Training Loss')
    #plt.xlabel('Epoch')
    #plt.ylabel('Loss')
    #plt.legend()

    #plt.subplot(1, 2, 2)
    #plt.plot(epochs, train_acc, label='Validation Accuracy')
    #plt.title('Validation Accuracy')
    #plt.xlabel('Epoch')
    #plt.ylabel('Accuracy (%)')
    #plt.legend()

    #plt.show()