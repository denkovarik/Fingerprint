from python import Python, PythonObject
from CustomNN import Custom_NN_Pytorch
from Data_Loader import MNIST_Data_Loader_Pytorch, MNIST_Data_Loader_Mojo

from testing import assert_equal, assert_true, assert_false
from tensor import Tensor, TensorSpec, TensorShape
from sys.info import simdwidthof, simdbitwidth
from algorithm import parallelize, vectorize
from utils.index import Index, IndexList
from random import randn, random_si64, seed
from pathlib import path
from python import Python, PythonObject
from math import exp
from NN_Utils import NN_Utils
from Data_Loader import MNIST_Data_Loader_Pytorch
from CustomNN import Custom_NN_Pytorch, Custom_NN_Mojo
from NN_Utils import NN_Utils
from test_utils import create_equivalent_mojo_tensor

alias type = DType.float64
alias simdwidth = simdwidthof[type]()
alias mu: Float64 = 0.01
alias beta1: Float64 = 0.9
alias beta2: Float64 = 0.99
alias epsilon: Float64 = 0.00000001
alias mini_batch_size: Int = 50
alias epochs: Int = 1
alias error_target: Float32 = .1
alias input_layer_size: Int = 16
alias hidden_layer_size: Int = 52
alias output_layer_size: Int = 26
alias data_width: Int = 17
alias data_size: Int = 20000
alias training_size: Int = 16000
alias validation_size: Int = 4000
     
        
        
def testNetwork(model: Custom_NN_Mojo, testloader: MNIST_Data_Loader_Mojo) -> Float64:
    var torch = Python.import_module("torch")

    var correct: Int = 0
    var total: Int = 0     

    for i in range(testloader.__len__()):
        var images = testloader.batchImages[i]
        var target = testloader.batchLabels[i]
        var output = model.forward(images)    
        
        var predicted: Tensor[DType.int64] = Tensor[DType.int64](TensorShape(output.shape()[0]))      
        for i in range(output.shape()[0]):
            var maxInd: Int = 0
            for j in range(output.shape()[1]):
                if output[Index(i,j)] > output[Index(i,maxInd)]:
                    maxInd = j
            predicted[Index(i)] = maxInd
            
        for j in range(predicted.shape()[0]):
            if predicted[Index(j)] == target[Index(j)]:
                correct = correct + 1
            total = total + 1

    var accuracy: Float64 = 100.0 * correct / total
    return accuracy


def main():
    var nn = Python.import_module("torch.nn")
    var optim = Python.import_module("torch.optim")
    var torch = Python.import_module("torch")
    var torchvision = Python.import_module("torchvision")
    var transforms = Python.import_module("torchvision.transforms")   
    var time = Python.import_module("time")
    var plt = Python.import_module("matplotlib.pyplot")
    
    var nn_utils = NN_Utils()
    
    var num_epochs: Int = 5
    var batchSize: Int = 64
    var inputShape: PythonObject = torch.Size([batchSize, 1, 28, 28])
    var learning_rate = 0.01
    
    var device: PythonObject = torch.device("cpu")
      
    # Load MNIST dataset
    var trainloader = MNIST_Data_Loader_Mojo(batchSize=batchSize, device=device, train=True, shuffle=True)
    var testloader = MNIST_Data_Loader_Mojo(batchSize=batchSize, device=device, train=False, shuffle=True)
           
    var train_losses: PythonObject = Python.list()
    var train_acc: PythonObject = Python.list()
    var epochs: PythonObject = Python.list()
    
    var model: Custom_NN_Mojo = Custom_NN_Mojo() 
    
    print("\nTraining Network")
    var startTime = time.perf_counter()
    for epoch in range(num_epochs):
        var running_loss: Float64 = 0.0
        var cnt: Float64 = 0.0
        for i in range(trainloader.__len__()):
            var images = trainloader.batchImages[i]
            var labels = trainloader.batchLabels[i]
            
            # Foward
            var log_softmax_mojo = model.forward(images)
   
            # Loss
            var loss_mojo: Float64 = model.loss(labels)
    
            # Backward
            model.backward()
            
            # Step
            model.step()
    
            running_loss = running_loss + loss_mojo

        # Test
        var accuracy: Float64 = testNetwork(model=model, testloader=testloader)
        #print("Epoch " + String(epoch + 1) + " Loss: " + String(running_loss / trainloader.__len__()))
        print("Epoch " + String(epoch + 1) + " Loss: " + String(running_loss / trainloader.__len__()) + ", Validation Accuracy: " + String(accuracy) + "%")
        
        train_losses.append(running_loss / trainloader.__len__())
        train_acc.append(accuracy)
        epochs.append(epoch+1)
        
    var endTime = time.perf_counter()
     
    print("Training completed in " + String(endTime - startTime) + " seconds")
      
    # Plot training loss and accuracy
    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.plot(epochs, train_losses, label='Training Loss')
    plt.title('Training Loss')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.plot(epochs, train_acc, label='Validation Accuracy')
    plt.title('Validation Accuracy')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy (%)')
    plt.legend()

    plt.show()